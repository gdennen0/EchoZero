# FaderEvent Object Reference Documentation
# Source: grandMA3 Dump() command on FaderEvent object
# Command: DataPool().Timecodes[101][1][11][1][1]:Dump()
# Date: [When this was captured]

## Overview

A FaderEvent represents a fader event that sets a specific fader value at a specific time within a FaderSubTrack. It controls fader levels and is similar to CmdEvent but for fader control.

**Hierarchy:** `DataPool().Timecodes[timecode_no][track_group_no][track_no][time_range_no][fader_subtrack_no][event_no]`

## Object Information

**Name:** Fader(Master)
**Class:** FaderEvent
**Path:** Root/ShowData/DataPools/1 'Default'/Timecodes/101 'Intro_Feel'/1 'Test'/5105 'BEAM'/TimeRange 1/FaderSubTrack 1/Fader(Master)

---

## Access Methods

### Basic Access

```lua
-- Access FaderEvent through hierarchy
local tc = DataPool().Timecodes[101]
local tg = tc[1]
local tracks = tg:Children()
local track = tracks[2]  -- Skip Marker at index 0
local time_ranges = track:Children()
local tr = time_ranges[1]
local sub_tracks = tr:Children()

-- Find FaderSubTrack
local fst = nil
for i = 1, #sub_tracks do
    local subtrack = sub_tracks[i]
    local class = subtrack:GetClass()
    if class == "FaderSubTrack" then
        fst = subtrack
        break
    end
end

-- Get FaderEvents
local events = fst:Children()
local event = events[1]  -- First FaderEvent
```

### Helper Function

```lua
function GetFaderEvent(tc_no, tg_idx, track_idx, tr_idx, fst_idx, event_idx)
    local tc = DataPool().Timecodes[tc_no]
    if not tc then return nil end
    
    local tg = tc[tg_idx]
    if not tg then return nil end
    
    local tracks = tg:Children()
    if not tracks[track_idx] then return nil end
    
    local track = tracks[track_idx]
    local time_ranges = track:Children()
    if not time_ranges[tr_idx] then return nil end
    
    local tr = time_ranges[tr_idx]
    local sub_tracks = tr:Children()
    if not sub_tracks[fst_idx] then return nil end
    
    local fst = sub_tracks[fst_idx]
    local class = fst:GetClass()
    if class ~= "FaderSubTrack" then return nil end
    
    local events = fst:Children()
    if not events[event_idx] then return nil end
    
    return events[event_idx]
end
```

---

## Properties

### Standard Properties

| Property | Type | Read Only | Description |
|----------|------|-----------|-------------|
| NAME | "Fader(Master)" | No | Event name |
| INDEX | "1" | Yes | Array index |
| COUNT | "0" | Yes | Number of children (always 0) |
| MEMORYFOOTPRINT | "320 Bytes" | Yes | Memory usage |
| NOTE | "" | No | Notes |
| HIDDEN | "No" | No | Visibility state |
| LOCK | "" | No | Lock status |

### Fader Properties

| Property | Type | Read Only | Description |
|----------|------|-----------|-------------|
| TOKEN | "FaderMaster" | No | Fader token reference |
| FADERVALUE | "0.00%" | No | Fader value |
| FADEOVERRIDE | "" | No | Fader override settings |
| TYPE | "1" | Yes | Event type (read-only) |

### Time Properties

| Property | Type | Read Only | Description |
|----------|------|-----------|-------------|
| TIME | "180.000000" | No | Event time |
| ABSTIME | "180.000000" | Yes | Absolute time (read-only) |
| RAWTIME | "3019898880" | Yes | Raw time value (read-only) |

### Reference Properties

| Property | Type | Read Only | Description |
|----------|------|-----------|-------------|
| TRACKGROUP | "1 'Test'" | Yes | Parent TrackGroup reference |
| TRACK | "5105 'BEAM'" | Yes | Parent Track reference |

### Accessing Properties

```lua
local event = GetFaderEvent(101, 1, 2, 1, 1, 1)

-- Access via property name (direct)
local name = event.name
local time = event.time
local token = event.token
local fadervalue = event.fadervalue

-- Access via :Get() method
local name = event:Get("NAME")
local time = event:Get("TIME")
local token = event:Get("TOKEN")
local fadervalue = event:Get("FADERVALUE")

-- Setting properties
event.time = "200.000000"
event.token = "FaderMaster"
event.fadervalue = "50.00%"
event.fadeoverride = ""
```

---

## Children

FaderEvents have no children. COUNT is always 0.

---

## Common Operations

### Getting Event Information

```lua
function GetFaderEventInfo(tc_no, tg_idx, track_idx, tr_idx, fst_idx, event_idx)
    local event = GetFaderEvent(tc_no, tg_idx, track_idx, tr_idx, fst_idx, event_idx)
    if not event then return nil end
    
    local info = {
        name = event.name or "Unknown",
        time = event.time or "?",
        token = event.token or "?",
        fadervalue = event.fadervalue or "?",
        trackgroup = event.trackgroup or "?",
        track = event.track or "?"
    }
    
    return info
end

-- Usage
local info = GetFaderEventInfo(101, 1, 2, 1, 1, 1)
if info then
    Printf("Event: " .. info.name)
    Printf("Time: " .. info.time)
    Printf("Fader: " .. info.token .. " = " .. info.fadervalue)
end
```

### Listing Events by Time Range

```lua
function ListFaderEventsByTimeRange(tc_no, tg_idx, track_idx, tr_idx, fst_idx, start_time, end_time)
    local tc = DataPool().Timecodes[tc_no]
    if not tc then return {} end
    
    local tg = tc[tg_idx]
    if not tg then return {} end
    
    local tracks = tg:Children()
    if not tracks[track_idx] then return {} end
    
    local track = tracks[track_idx]
    local time_ranges = track:Children()
    if not time_ranges[tr_idx] then return {} end
    
    local tr = time_ranges[tr_idx]
    local sub_tracks = tr:Children()
    
    local fst = nil
    for i = 1, #sub_tracks do
        local subtrack = sub_tracks[i]
        local class = subtrack:GetClass()
        if class == "FaderSubTrack" then
            fst = subtrack
            break
        end
    end
    
    if not fst then return {} end
    
    local events = fst:Children()
    local found = {}
    
    for i = 1, #events do
        local event = events[i]
        local time = tonumber(event.time) or 0
        
        if time >= start_time and time <= end_time then
            table.insert(found, {event = event, index = i, time = time})
        end
    end
    
    return found
end

-- Usage: Find events between 180 and 200 seconds
local events = ListFaderEventsByTimeRange(101, 1, 2, 1, 1, 180, 200)
Printf("Found " .. #events .. " events in time range")
```

### Finding Events by Fader Token

```lua
function FindFaderEventsByToken(tc_no, tg_idx, track_idx, tr_idx, fst_idx, token)
    local tc = DataPool().Timecodes[tc_no]
    if not tc then return {} end
    
    local tg = tc[tg_idx]
    if not tg then return {} end
    
    local tracks = tg:Children()
    if not tracks[track_idx] then return {} end
    
    local track = tracks[track_idx]
    local time_ranges = track:Children()
    if not time_ranges[tr_idx] then return {} end
    
    local tr = time_ranges[tr_idx]
    local sub_tracks = tr:Children()
    
    local fst = nil
    for i = 1, #sub_tracks do
        local subtrack = sub_tracks[i]
        local class = subtrack:GetClass()
        if class == "FaderSubTrack" then
            fst = subtrack
            break
        end
    end
    
    if not fst then return {} end
    
    local events = fst:Children()
    local found = {}
    
    for i = 1, #events do
        local event = events[i]
        if event.token == token then
            table.insert(found, {event = event, index = i})
        end
    end
    
    return found
end

-- Usage: Find all "FaderMaster" events
local master_events = FindFaderEventsByToken(101, 1, 2, 1, 1, "FaderMaster")
Printf("Found " .. #master_events .. " FaderMaster events")
```

### Finding Events by Value Range

```lua
function FindFaderEventsByValueRange(tc_no, tg_idx, track_idx, tr_idx, fst_idx, min_value, max_value)
    local tc = DataPool().Timecodes[tc_no]
    if not tc then return {} end
    
    local tg = tc[tg_idx]
    if not tg then return {} end
    
    local tracks = tg:Children()
    if not tracks[track_idx] then return {} end
    
    local track = tracks[track_idx]
    local time_ranges = track:Children()
    if not time_ranges[tr_idx] then return {} end
    
    local tr = time_ranges[tr_idx]
    local sub_tracks = tr:Children()
    
    local fst = nil
    for i = 1, #sub_tracks do
        local subtrack = sub_tracks[i]
        local class = subtrack:GetClass()
        if class == "FaderSubTrack" then
            fst = subtrack
            break
        end
    end
    
    if not fst then return {} end
    
    local events = fst:Children()
    local found = {}
    
    for i = 1, #events do
        local event = events[i]
        -- Parse percentage value (e.g., "50.00%" -> 50.0)
        local value_str = event.fadervalue or "0%"
        local value = tonumber(string.match(value_str, "([%d%.]+)")) or 0
        
        if value >= min_value and value <= max_value then
            table.insert(found, {event = event, index = i, value = value})
        end
    end
    
    return found
end

-- Usage: Find events with fader value between 50% and 100%
local events = FindFaderEventsByValueRange(101, 1, 2, 1, 1, 50, 100)
Printf("Found " .. #events .. " events with fader value 50-100%")
```

### Dumping FaderEvent

```lua
-- Dump entire FaderEvent object
local event = GetFaderEvent(101, 1, 2, 1, 1, 1)
event:Dump()

-- Or via command line
-- Lua "DataPool().Timecodes[101][1][11][1][1]:Dump()"
```

---

## Examples

### Example 1: Access FaderEvent and Display Properties

```lua
local event = GetFaderEvent(101, 1, 2, 1, 1, 1)
if event then
    Printf("Event: " .. event.name)
    Printf("Time: " .. event.time)
    Printf("Token: " .. event.token)
    Printf("Value: " .. event.fadervalue)
end
```

### Example 2: Iterate All Events in FaderSubTrack

```lua
function IterateFaderEvents(tc_no, tg_idx, track_idx, tr_idx, fst_idx, callback)
    local tc = DataPool().Timecodes[tc_no]
    if not tc then return false end
    
    local tg = tc[tg_idx]
    if not tg then return false end
    
    local tracks = tg:Children()
    if not tracks[track_idx] then return false end
    
    local track = tracks[track_idx]
    local time_ranges = track:Children()
    if not time_ranges[tr_idx] then return false end
    
    local tr = time_ranges[tr_idx]
    local sub_tracks = tr:Children()
    
    local fst = nil
    for i = 1, #sub_tracks do
        local subtrack = sub_tracks[i]
        local class = subtrack:GetClass()
        if class == "FaderSubTrack" then
            fst = subtrack
            break
        end
    end
    
    if not fst then return false end
    
    local events = fst:Children()
    
    for i = 1, #events do
        local event = events[i]
        callback(event, i)
    end
    
    return true
end

-- Usage
IterateFaderEvents(101, 1, 2, 1, 1, function(event, index)
    Printf(string.format("Event [%d]: %s at %s = %s", 
          index, event.name, event.time, event.fadervalue))
end)
```

### Example 3: Get Event Statistics

```lua
function GetFaderEventStats(tc_no, tg_idx, track_idx, tr_idx, fst_idx)
    local tc = DataPool().Timecodes[tc_no]
    if not tc then return nil end
    
    local tg = tc[tg_idx]
    if not tg then return nil end
    
    local tracks = tg:Children()
    if not tracks[track_idx] then return nil end
    
    local track = tracks[track_idx]
    local time_ranges = track:Children()
    if not time_ranges[tr_idx] then return nil end
    
    local tr = time_ranges[tr_idx]
    local sub_tracks = tr:Children()
    
    local fst = nil
    for i = 1, #sub_tracks do
        local subtrack = sub_tracks[i]
        local class = subtrack:GetClass()
        if class == "FaderSubTrack" then
            fst = subtrack
            break
        end
    end
    
    if not fst then return nil end
    
    local events = fst:Children()
    
    local stats = {
        total_events = #events,
        tokens = {},
        time_range = {min = nil, max = nil},
        value_range = {min = nil, max = nil}
    }
    
    for i = 1, #events do
        local event = events[i]
        
        -- Count tokens
        local token = event.token or "Unknown"
        stats.tokens[token] = (stats.tokens[token] or 0) + 1
        
        -- Track time range
        local time = tonumber(event.time) or 0
        if not stats.time_range.min or time < stats.time_range.min then
            stats.time_range.min = time
        end
        if not stats.time_range.max or time > stats.time_range.max then
            stats.time_range.max = time
        end
        
        -- Track value range
        local value_str = event.fadervalue or "0%"
        local value = tonumber(string.match(value_str, "([%d%.]+)")) or 0
        if not stats.value_range.min or value < stats.value_range.min then
            stats.value_range.min = value
        end
        if not stats.value_range.max or value > stats.value_range.max then
            stats.value_range.max = value
        end
    end
    
    return stats
end
```

---

## Related Documentation

- See `../FaderSubTrack.txt` for FaderSubTrack documentation
- See `../../CmdSubTrack/CmdEvent/CmdEvent.txt` for CmdEvent documentation (similar structure)
- See `TIMECODE_STRUCTURE.md` for overall timecode hierarchy
